---
- name: Setup Workspaces Server
  hosts: all
  become: true
  gather_facts: true

  vars:
    app_dir: /opt/workspaces
    # Terraform環境変数から取得(TF_VAR_*)
    dns_zone: "{{ lookup('ansible.builtin.env', 'TF_VAR_domain') }}"
    domain: "ws.{{ lookup('ansible.builtin.env', 'TF_VAR_domain') }}"
    internal_switch_name: "{{ lookup('ansible.builtin.env', 'TF_VAR_internal_switch_name') }}"
    internal_nic_ip: "{{ lookup('ansible.builtin.env', 'TF_VAR_internal_nic_ip') }}"
    ws_github_client_id: "{{ lookup('ansible.builtin.env', 'WS_GITHUB_CLIENT_ID') }}"
    ws_github_client_secret: "{{ lookup('ansible.builtin.env', 'WS_GITHUB_CLIENT_SECRET') }}"
    docs_github_client_id: "{{ lookup('ansible.builtin.env', 'DOCS_GITHUB_CLIENT_ID') }}"
    docs_github_client_secret: "{{ lookup('ansible.builtin.env', 'DOCS_GITHUB_CLIENT_SECRET') }}"
    target_organization: "{{ lookup('ansible.builtin.env', 'TARGET_ORGANIZATION') }}"
    # email は優先的に環境変数 DEPLOYER_EMAIL から取得
    # 未設定の場合は admin@<domain> をフォールバックとして使用
    email: "{{ lookup('ansible.builtin.env', 'DEPLOYER_EMAIL') | default('admin@' ~ dns_zone) }}"
    # テスト時は true, 本番時は false
    le_staging: false
    # 変数に応じて URL をセット (前の回答と同じロジック)
    le_server_url: >-
      {{
        'https://acme-staging-v02.api.letsencrypt.org/directory'
        if le_staging
        else
        'https://acme-v02.api.letsencrypt.org/directory'
      }}
  pre_tasks:
    - name: Wait for SSH connection to be available
      ansible.builtin.wait_for_connection:
        delay: 3       # 最初のリトライまで10秒待機
        timeout: 300    # タイムアウト（300秒 = 5分）

  tasks:
    - name: Ensure DOMAIN is provided via environment variable
      ansible.builtin.assert:
        that:
          - domain is defined
          - domain != ''
        fail_msg: |
          TF_VAR_domain environment variable is not set.
          Set it before running Ansible, for example:
            export TF_VAR_domain=pcs.example.com
          Or run with: TF_VAR_domain=pcs.example.com ansible-playbook -i inventory.ini playbook.yml

    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: true
        cache_valid_time: 3600

    - name: Upgrade all packages to the latest version
      ansible.builtin.apt:
        upgrade: dist
        update_cache: true
      register: apt_upgrade_result

    - name: Reboot if kernel was upgraded
      when: apt_upgrade_result.changed and 'linux-image' in apt_upgrade_result.stdout | default('')
      block:
        - name: Reboot
          ansible.builtin.reboot:
            reboot_timeout: 600
        - name: Wait for SSH connection to be available
          ansible.builtin.wait_for_connection:
            delay: 10       # 最初のリトライまで10秒待機
            timeout: 300    # タイムアウト（300秒 = 5分）

    - name: Install required system packages
      ansible.builtin.apt:
        name:
          - git
          - curl
          - certbot
          - apt-transport-https
          - ca-certificates
          - gnupg
          - lsb-release
          - iputils-ping
          - iptables
          - iptables-persistent
        state: present

    - name: Add Docker GPG key
      ansible.builtin.apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present

    - name: Add Docker repository
      ansible.builtin.apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present

    - name: Install Docker packages
      ansible.builtin.apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-buildx-plugin
          - docker-compose-plugin
        state: present
        update_cache: true

    - name: Add ubuntu user to docker group
      ansible.builtin.user:
        name: ubuntu
        groups: docker
        append: true

    - name: Ensure Docker is running
      ansible.builtin.systemd:
        name: docker
        state: started
        enabled: true

    - name: Get network interface facts
      ansible.builtin.setup:
        gather_subset:
          - network

    - name: Identify primary network interface (with default route)
      ansible.builtin.set_fact:
        primary_nic: "{{ ansible_default_ipv4.interface }}"

    - name: Identify secondary network interface (if internal_nic_ip is configured)
      when: internal_nic_ip != ''
      block:
        - name: Find secondary interface (eth1 if exists)
          ansible.builtin.set_fact:
            secondary_nic: "{{ 'eth1' if 'eth1' in ansible_interfaces else '' }}"

        - name: Configure secondary network interface
          when: secondary_nic != ''
          ansible.builtin.copy:
            dest: "/etc/netplan/51-secondary-nic.yaml"
            content: |
              network:
                version: 2
                ethernets:
                  {{ secondary_nic }}:
                    addresses:
                      - {{ internal_nic_ip }}
            owner: root
            group: root
            mode: '0644'
          register: netplan_config

        - name: Apply netplan configuration
          ansible.builtin.command:
            cmd: netplan apply
          when: netplan_config.changed
          changed_when: true

    - name: Deploy iptables rules file
      ansible.builtin.template:
        src: templates/iptables-rules.v4.j2
        dest: /etc/iptables/rules.v4
        owner: root
        group: root
        mode: '0644'
      register: iptables_rules

    - name: Apply iptables rules if changed
      ansible.builtin.shell:
        cmd: iptables-restore /etc/iptables/rules.v4 && systemctl restart docker
      when: iptables_rules.changed
      changed_when: true

    - name: Create codespace group (GID 1000)
      ansible.builtin.group:
        name: codespace
        gid: 1000
        state: present

    - name: Create codespace user (UID 1000)
      ansible.builtin.user:
        name: codespace
        uid: 1000
        group: codespace
        groups: docker
        append: true
        shell: /bin/bash
        create_home: true
        state: present

    - name: Create application directory
      ansible.builtin.file:
        path: "{{ app_dir }}"
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Create required subdirectories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'
      loop:
        - "{{ app_dir }}/app"
        - "{{ app_dir }}/nginx"
        - "{{ app_dir }}/nginx/conf.d"
        - "{{ app_dir }}/workspaces"

    - name: Create workspace and build log directories for codespace user
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: codespace
        group: codespace
        mode: '0755'
      loop:
        - /home/codespace/workspaces
        - /home/codespace/buildlogs

    - name: Copy application files
      ansible.builtin.copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        owner: ubuntu
        group: ubuntu
        mode: '0644'
      loop:
        - {src: '../app/', dest: '{{ app_dir }}/app/'}
        - {src: '../docs-renew/', dest: '{{ app_dir }}/docs-renew/'}
        - {src: '../docker/', dest: '{{ app_dir }}/'}
      register: app_files_copy

    - name: Deploy production nginx configuration with SSL
      ansible.builtin.template:
        src: ../nginx/nginx.conf.j2
        dest: "{{ app_dir }}/nginx/nginx.conf"
        owner: ubuntu
        group: ubuntu
        mode: '0644'
      register: nginx_conf

    - name: Deploy common auth configuration
      ansible.builtin.template:
        src: ../nginx/auth-common.conf.j2
        dest: "{{ app_dir }}/nginx/conf.d/auth-common.conf"
        owner: ubuntu
        group: ubuntu
        mode: '0644'
      register: nginx_auth_conf

    - name: Create environment file
      ansible.builtin.template:
        src: templates/env.j2
        dest: "{{ app_dir }}/app/.env"
        owner: ubuntu
        group: ubuntu
        mode: '0600'
      register: env_file

    - name: Create certbot webroot directory
      ansible.builtin.file:
        path: /var/www/certbot
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Create docs directory
      ansible.builtin.file:
        path: /var/docs
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Create nginx html directory for error pages
      ansible.builtin.file:
        path: /usr/share/nginx/html
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Copy workspace starting page to nginx html directory
      ansible.builtin.copy:
        src: ../app/public/workspace-starting.html
        dest: /usr/share/nginx/html/workspace-starting.html
        owner: ubuntu
        group: ubuntu
        mode: '0644'

    - name: Reset SSH connection to apply docker group membership
      ansible.builtin.meta: reset_connection

    - name: Create Docker network for workspaces
      community.docker.docker_network:
        name: workspaces_internal
        driver: bridge
        ipam_config:
          - subnet: 172.19.0.0/16
            gateway: 172.19.0.1
        state: present

    - name: Create systemd service for Docker Compose
      ansible.builtin.copy:
        dest: /etc/systemd/system/workspaces.service
        content: |
          [Unit]
          Description=Workspaces Docker Compose Application
          Requires=docker.service
          After=docker.service

          [Service]
          Type=oneshot
          RemainAfterExit=yes
          WorkingDirectory={{ app_dir }}
          ExecStart=/usr/bin/docker compose up -d
          ExecStop=/usr/bin/docker compose stop
          TimeoutStopSec=300
          User=ubuntu
          Group=ubuntu

          [Install]
          WantedBy=multi-user.target
        mode: '0644'
      register: workspaces_service

    - name: Reload systemd daemon if service changed
      ansible.builtin.systemd:
        daemon_reload: true
      when: workspaces_service.changed

    - name: Build Docker containers (only if app files changed)
      ansible.builtin.command:
        cmd: docker compose build
        chdir: "{{ app_dir }}"
      become: true
      become_user: ubuntu
      when: app_files_copy.changed or env_file.changed
      changed_when: true
      register: docker_build

    - name: Check if SSL certificate already exists
      ansible.builtin.stat:
        path: "/etc/letsencrypt/live/{{ domain }}/fullchain.pem"
      register: ssl_cert

    - name: Check if docs SSL certificate already exists
      ansible.builtin.stat:
        path: "/etc/letsencrypt/live/docs.{{ dns_zone }}/fullchain.pem"
      register: docs_ssl_cert

    - name: Obtain SSL certificates with certbot (webroot mode)
      when: not ssl_cert.stat.exists or not docs_ssl_cert.stat.exists
      block:
        - name: Stop workspaces service
          ansible.builtin.systemd:
            name: workspaces
            state: stopped

        - name: Obtain SSL certificate for ws domain
          ansible.builtin.command:
            cmd: >
              certbot certonly --standalone --non-interactive --agree-tos
              --email {{ email }} -d {{ domain }} --server {{ le_server_url }}
          changed_when: true

        - name: Obtain SSL certificate for docs domain
          ansible.builtin.command:
            cmd: >
              certbot certonly --standalone --non-interactive --agree-tos
              --email {{ email }} -d docs.{{ dns_zone }} --server {{ le_server_url }}
          changed_when: true

        - name: Modify configuration as webroot mode (renewal conf)
          community.general.ini_file:
            path: /etc/letsencrypt/renewal/{{ item.domain }}.conf
            section: renewalparams
            option: "{{ item.option }}"
            value: "{{ item.value }}"
            mode: '0644'
          loop:
            - { domain: "{{ domain }}", option: 'authenticator', value: 'webroot' }
            - { domain: "{{ domain }}", option: 'webroot_path', value: '/var/www/certbot' }
            - { domain: "{{ domain }}", option: 'server', value: le_server_url }
            - { domain: "docs.{{ dns_zone }}", option: 'authenticator', value: 'webroot' }
            - { domain: "docs.{{ dns_zone }}", option: 'webroot_path', value: '/var/www/certbot' }
            - { domain: "docs.{{ dns_zone }}", option: 'server', value: le_server_url }

        - name: Remove standalone pre/post hooks from renewal configuration
          community.general.ini_file:
            path: /etc/letsencrypt/renewal/{{ item.domain }}.conf
            section: renewalparams
            option: "{{ item.option }}"
            state: absent
            mode: '0644'
          loop:
            - { domain: "{{ domain }}", option: 'pre_hook' }
            - { domain: "{{ domain }}", option: 'post_hook' }
            - { domain: "docs.{{ dns_zone }}", option: 'pre_hook' }
            - { domain: "docs.{{ dns_zone }}", option: 'post_hook' }

    - name: Enable and start workspaces service
      ansible.builtin.systemd:
        name: workspaces
        enabled: true
        state: >-
          {{
            'restarted' if (
              app_files_copy.changed or
              nginx_conf.changed or
              nginx_auth_conf.changed or
              env_file.changed
            ) else 'started'
          }}

    - name: Copy certificate renewal script
      ansible.builtin.copy:
        src: files/renew-cert.sh
        dest: /usr/local/bin/renew-cert.sh
        owner: root
        group: root
        mode: '0755'

    - name: Set up certbot renewal cron job for workspaces (daily at 3 AM)
      ansible.builtin.cron:
        name: "Renew Let's Encrypt certificates for workspaces and reload nginx"
        minute: "0"
        hour: "3"
        job: "/usr/local/bin/renew-cert.sh {{ domain }} >> /var/log/certbot-renewal.log 2>&1"
        user: root

    - name: Set up certbot renewal cron job for docs (daily at 3:10 AM)
      ansible.builtin.cron:
        name: "Renew Let's Encrypt certificates for docs and reload nginx"
        minute: "10"
        hour: "3"
        job: "/usr/local/bin/renew-cert.sh docs.{{ dns_zone }} >> /var/log/certbot-renewal.log 2>&1"
        user: root

    - name: Wait for application to be ready
      ansible.builtin.wait_for:
        port: 443
        delay: 3
        timeout: 60

    - name: Display service information
      ansible.builtin.debug:
        msg: "Service is now available at https://{{ domain }}"
